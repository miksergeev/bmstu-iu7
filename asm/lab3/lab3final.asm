
StkSeg SEGMENT PARA STACK 'STACK'
	DB 200h DUP (?)
StkSeg ENDS

DataS SEGMENT WORD 'DATA'
InputMessage DB 13
	DB 'Input two digits from 0 to 5:	' ;текст сообщения
	DB '$'
DataS ENDS

DataS SEGMENT WORD 'DATA'
OutputMessageSum DB 13 
	DB 'Sum equals:	' ;текст сообщения
	DB '$'
OutputMessageSum10 DB 13 
	DB 'Sum equals:	10' ;текст сообщения
	DB '$' 
OutputMessageSumMoreThan10 DB 13 
	DB 'At least one of the numbers is more than 5' ;текст сообщения
	DB '$' 
OutputMessageDifference DB 13 
	DB 'Difference equals:	' ;текст сообщения
	DB '$' ;ограничитель для функции DOS
DataS ENDS


Code SEGMENT WORD 'CODE'
	ASSUME CS:Code, DS:DataS
DispMsg:
	MOV AX, DataS ;загрузка в AX адреса сегмента данных
	MOV DS, AX ;установка DS
	MOV DX, OFFSET InputMessage ;DS:DX - адрес строки
	MOV AH, 9 ;AH=09 для вызова прерывания и вывода на экран строки
	int 21h ;вызов функции DOS

MOV DL,0Ah ; переносим в DL символ для начала новой строки (его код - 0Ah или 10d, далее в этой программе будем использовать шестнадцатеричные коды символов)
MOV AH, 02 ; устанавливаем функцию прерывания для вывода символа начала новой строки
INT 21h ; выводим символ начала новой строки

MOV AH, 01
INT 21h ; ввод первой цифры, её ASCII-код сохранится в AL
MOV BH, AL ; перенесём его в BH, регистр AL нам ещё понадобится при вводе второй цифры, регистр BX в целом мы будем использовать для сложения, а CX - для вычитания. Можно использовать меньшее количество регистров, но для большей наглядности сделаем всё же так

MOV DL, 20h ; поместим в DL код символа пробела чтобы потом добавить его между цифрами
MOV AH, 02
INT 21h ; выведем пробел после первой цифры

MOV AH, 01
INT 21h ; ввод второй цифры
MOV BL, AL; помещаем код второй цифры в BL, теперь оба кода хранятся в BX

MOV CH, BH
MOV CL, BL ; перенесём их также в CX

ADD BH, BL ; складываем коды обеих цифр
SUB BH, 30h ; чтобы впоследствии получить не символ, ASCII-код которого представлен суммой двух кодов, а именно сумму, отнимем 30h (потому что это 3 строки в начале таблицы,3*10h=3*16d)

MOV DL, 0Ah ; перенесём в DL символ начала новой строки чтобы отобразить результат сложения уже в ней
MOV AH, 02
INT 21h ; переходим на новую строку, мы уже делали это в начале

	MOV AX, DataS ;загрузка в AX адреса сегмента данных
	MOV DS, AX ;установка DS
	MOV DX, OFFSET OutputMessageSum ;DS:DX - адрес строки
	MOV AH, 9 ;AH=09 для вызова прерывания и вывода на экран строки
	int 21h ;вызов функции DOS

MOV DL, BH ; регистр DL нам теперь не нужен, перенесём туда код суммы для вывода

CMP DL,3Ah ; проверяем, равна ли сумма цифр десяти (5+5 - единственный возможный случай при соблюдении заданного диапазона ввода, 3Ah - код, следующий за цифрой "9"). Если будет равна - выведем это значение. Если будет больше - выведем соответствующее сообщение. Если она всё же меньше - выведем сумму цифр

JE EQUAL10 ; если она равна десяти - перейдём к команде вывода соответствующего сообщения, в рамках лабораторной работы сделаем это в текстовом виде, хотя можно также просто вывести два символа "1" и "0" по очереди, не вводя дополнительный текст

JG MORE10 ; если она больше десяти - сообщим, что хотя бы одно из чисел больше пяти

MOV AH, 02 ; если же сумма меньше десяти (а код, соответственно, меньше 3Ah), просто устанавливаем функцию 02 прерывания 21h для вывода суммы
INT 21h ; выводим сумму цифр

JMP DIFFERENCE ; в этом случае можно переходить к выводу разности

EQUAL10:
MOV AX, DataS ;загрузка в AX адреса сегмента данных
	MOV DS, AX ;установка DS
	MOV DX, OFFSET OutputMessageSum10 ;DS:DX - адрес строки
	MOV AH, 9 ;AH=09 для вызова прерывания и вывода на экран строки
	int 21h ;вызов функции DOS; этот абзац кода мы написали чтобы вывести на экран "10" в единственном случае - 5+5
JMP DIFFERENCE

MORE10:
MOV AX, DataS ;загрузка в AX адреса сегмента данных
	MOV DS, AX ;установка DS
	MOV DX, OFFSET OutputMessageSumMoreThan10 ;DS:DX - адрес строки
	MOV AH, 9 ;AH=09 для вызова прерывания и вывода на экран строки
	int 21h ;вызов функции DOS; этот абзац кода мы написали чтобы вывести на экран сообщение, что хотя бы одно из введённых чисел больше пяти, здесь символ перехода к выводу разности уже можно не ставить, поскольку он будет через одну строчку в коде

DIFFERENCE:

MOV DL,0Ah ; прежде всего перейдём на новую строку
MOV AH, 02 ; устанавливаем функцию прерывания для вывода символа начала новой строки
INT 21h ; выводим символ начала новой строки


MOV AX, DataS ;загрузка в AX адреса сегмента данных
	MOV DS, AX ;установка DS
	MOV DX, OFFSET OutputMessageDifference ; теперь выведем текстовое сообщения для вывода разности
	MOV AH, 9 ;AH=09 для вызова прерывания и вывода на экран строки
	int 21h ;вызов функции DOS; 


CMP CH, CL ;сравним коды первого и второго числа, от этого будет зависит, является ли разность отрицательной или нет

JL LESSTHANZERO ; если разность действительно меньше нуля, перейдём к расчёту и выводу отрицательного значения

SUB CH, CL ; если первое число не меньше второго, находим разность как обычно
ADD CH, 30h ; чтобы получить число, а не его ASCII-код, аналогично мы делали с суммой, только там 30h мы отнимали, а не прибавляли

MOV DL, CH ; переносим в DL ASCII-код разности для вывода
MOV AH,02
INT 21h

JMP THE_END


LESSTHANZERO:
SUB CL, CH ; поскольку первое число меньше второго, вычтем из кода второго числа код первого, получив модуль, а потом поставим знак "минус" перед ним
ADD CL, 30h ; чтобы получить число, а не его ASCII-код

MOV DL, 2Dh ; поместим в DL код знака "минус"
MOV AH, 02 ; и выведем его
INT 21h

MOV DL, CL ; а после него - ASCII-код цифры (разности)
MOV AH, 02 ; выводим
INT 21h

THE_END:
MOV AH, 4Ch ; завершаем процесс
INT 21h

Code ENDS
END DispMsg
