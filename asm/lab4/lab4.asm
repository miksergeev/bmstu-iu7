StkSeg SEGMENT PARA STACK 'STACK'
	DB 200h DUP (?)
StkSeg ENDS

Input SEGMENT WORD 'DATA'

InputMessage DB 13
	DB 'Input some symbols:	' , 0Ah ;текст сообщения, 0Ah здесь - символ перехода на новую строку, а не прерывание
	DB '$'

String DB 20, 20 DUP (?)
Input ENDS


Code SEGMENT WORD 'CODE'
	ASSUME CS:Code, DS:Input
DispMsg:


	MOV AX, Input ;загрузка в AX адреса сегмента данных
	MOV DS, AX ;установка DS
	MOV DX, OFFSET InputMessage ;DS:DX - адрес строки
	MOV AH, 9 ;AH=09 для вызова прерывания и вывода на экран строки
	int 21h ;вызов функции DOS

MOV DX, offset String

MOV AH, 0Ah; для ввода строки
INT 21h

XOR CX, CX
MOV SI, offset String + 1
MOV CL, byte ptr [SI]
XOR AX, AX ; AX будет вспомогательным регистром
XOR BX, BX ; в BH будем хранить число цифр подряд, в BL - адрес проверяемого
XOR DX, DX; в DH будем хранить максимальное число цифр подряд, в DL - адрес последней цифры из этого набора

compare:

	ADD SI, 1 ; получаем адрес первого, второго и так далее символа
	CMP byte ptr [SI], '0' ; сравниваем его код с кодом нуля
	JB againzero
	CMP byte ptr [SI], '9' ; сравниваем с кодом девятки
	JA againzero ; если больше (то есть вообще не цифра) - повторяем цикл уже со следующим символом
	
	
	ADD BH, 1 ; прибавляем к BH 1. Здесь у нас хранится число цифр подряд 
	MOV AX, SI ; перемещаем адрес в AX. Сейчас здесь хранится адрес проверяемой цифры
	MOV BL, AL ; потому что не можем перенести значение 16-разрядного регистра (SI) в 8-разрядный (BL); сейчас в BL - адрес смещения проверяемой цифры

	
	CMP BH, DH ; в DH будем хранить максимальное число цифр подряд
	JAE maxplus
	JB again
	
	maxplus:
	MOV DX, BX ; переносим в DX адрес последней цифры (из BL в DL) и максимальное число цифр подряд (из BH в DH)
	JMP again
	
	againzero:
	XOR BX, BX
	
	again:
	loop compare

MOV BX, DX ; сохраняем в BH максимальное число цифр подряд, а в BL - сегмент последней цифры


MOV AH, 02
MOV DL, 0Ah ; переход на следующую строку
INT 21h

	XOR SI, SI
	XOR AX, AX
	XOR DX, DX ; 
	MOV DL, BL ; теперь в DL - сегмент последней цифры подряд
	MOV SI, DX ; теперь в SI лежит сегмент последней цифры
	XOR CX, CX
	MOV CL, BH ; используем число этих цифр как счётчик цикла
    XOR BX, BX ; а освободившийся регистр BX будем использовать для сложения (в нашей задаче максимальное число вводимых символов
			   ; ограничено 19-ю, поэтому их сумма не будет превышать 19*9=171. Плюс есть запас в 48 (или 30h) для ASCII-кода, поэтому
			   ; максимальное число, хранящееся в этом регистре не будет превышать 171+48=219 - одного байта нам как раз будет достаточно
			   ; если же мы ставили бы задачу вводу 50-и вводимых символов - пришлось бы использовать два байта (шестнадцатиразрядный регистр)
			   ; на случай изменения нашей задачи и увеличения количества вводимых символов будем использовать всё же два байта
output:
	MOV DL, byte ptr [SI] ; помещаем ASCII-код последнего, затем предпоследнего и т.д. символа в DL для посимвольного вывода
	ADD BX, DX ; так как DL = 0, будем складывать коды чисел, с каждой итерацией сохраняя результат в BX
	SUB BX, 30h ; не забывая вычитать 30h чтобы оставить только число (похожую задачу мы выполняли на одной из первых лабораторных работ)
	MOV AH, 02
	INT 21h
	SUB SI, 1
	
	loop output

MOV AH, 02
MOV DL, 0Ah ; переход на следующую строку
INT 21h
	
	; теперь приступаем к поразрядному выводу суммы этих цифр
	MOV AX, BX ; в BX у нас находится сумма цифр, перенесём её в AX
	MOV CX, BX ; и в CX
	XOR DX, DX ; на всякий случай, чтобы остаток от деления записывался без искажений
	
	; очевидно, что вывод суммы этих цифр можно реализовать в виде цикла с пятью итерациями - деление на 10000, 1000, 100, 10 и 1
	; и поразрядный вывод результата деления, 
	; либо же класть значения разрядов в память и выводить как строку с помощью функции 9 21-го прерывания
	; В силу небольшого количества итераций я предпочёл выводить результат вручную для каждого разряда
	; последующие условные переходы введены, чтобы выводились числа вида 125, а не 00125 
	; и в то же время чтобы не "потерялись" нули на месте некоторых разрядов (если они там будут)
	; - то есть чтобы вместо числа 203 не получилось 23
	
	CMP AX, 10000d ; сумма цифр >=10000?
	JAE output10000
	CMP AX, 1000d ; >=1000?
	JAE output1000
	CMP AX, 100d ; >=100?
	JAE output100
	CMP AX, 10d ;>=10?
	JAE output10
	JMP outputone ; если меньше десяти - выводим как цифру
	
	output10000:
	MOV BX, 10000d ; переносим в BX первый делитель
	DIV BX ; делим сумму цифр на 10000
	MOV CX, DX ; перенесём в CX остаток от деления
	MOV DX, AX ; а в DX - получившуюся цифру для вывода
	ADD DX, 30h ; не забывая прибавить 30h (=48d)
	
	MOV AH, 02
	INT 21h ; выводим первую цифру
	
	output1000:
	MOV BX, 1000d ; переносим в BX второй делитель
	DIV BX ; делим сумму цифр на 1000
	MOV CX, DX ; перенесём в CX остаток от деления
	MOV DX, AX ; а в DX - получившуюся цифру для вывода
	ADD DX, 30h ; не забывая прибавить 30h (=48d)
	
	MOV AH, 02
	INT 21h ; выводим вторую цифру
	
	output100:
	MOV BX, 100d ; переносим в BX второй делитель
	DIV BX ; делим сумму цифр на 100
	MOV CX, DX ; перенесём в CX остаток от деления
	MOV DX, AX ; а в DX - получившуюся цифру для вывода
	ADD DX, 30h ; не забывая прибавить 30h (=48d)
	
	MOV AH, 02
	INT 21h ; выводим третью цифру
	
	output10:
	MOV BX, 10d ; переносим в BX второй делитель
	DIV BX ; делим сумму цифр на 100
	MOV CX, DX ; перенесём в CX остаток от деления
	MOV DX, AX ; а в DX - получившуюся цифру для вывода
	ADD DX, 30h ; не забывая прибавить 30h (=48d)
	
	MOV AH, 02
	INT 21h ; выводим четвёртую цифру
	
	outputone:
	MOV DL, CL
	ADD DX, 30h
	MOV AH, 02
	INT 21h ; выводим последнюю цифру

MOV AH, 4Ch ; завершаем процесс
INT 21h

Code ENDS
END DispMsg